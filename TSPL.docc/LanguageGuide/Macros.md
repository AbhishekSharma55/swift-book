# Macros

Transform code at compile time to automate generate repetitive code.

Macros transform your source code when you compile it,
letting you avoid writing out repetitive code by hand
and omit boilerplate code.

At a high level, macros are expanded as follows:

1. The compiler reads the code,
   creating an in-memory representation of the syntax.

1. The compiler sends part of the in-memory representation
   to the macro implementation,
   which expands the macro.

1. The compiler replaces the macro call with its expanded form,
   and then continues with compilation.

![](macro-expansion)

Expanding a macro is always an additive operation:
Macros add new code,
but they never delete code
or modify code that you wrote by hand.

Both the input to a macro and the output of macro expansion
are checked to ensure they're syntactically valid Swift code.
Likewise, the values you pass to a macro
and the values in code generated by a macro
are checked to ensure they have the correct types.

Swift has two kinds of macros.
*Attached macros* modify the declaration that they're attached to.
*Freestanding macros* appear on their own,
without being attached to a declaration.

## Freestanding Macros

To call a freestanding macro,
you write a number sign (`#`) before its name,
followed by any arguments to the macro in parentheses.
For example:

```swift
let currentLine = #line
#warning("Something's wrong")
```

In the first line,
`#line` is a call to the `line` macro from the Swift standard library.
When you compile this code,
Swift calls that macro's implementation,
which replaces `#line` with the current line number.
In the second line,
`#warning` calls another macro from the standard library
to produce a custom warning when the code is compiled.

Freestanding macros can produce a value, like `#line`,
or they can perform an action at compile time, like `#warning`.
<!-- SE-0397: or they can generate new declarations.  -->

## Attached Macros

To call an attached macro,
you write an at sign (`@`) before its name,
followed by any arguments to the macro in parentheses.

Attached macros modify the declaration that they're attached to.
They add code to that declaration,
like defining a new method or adding conformance to a protocol.

For example, consider the following code
that doesn't use macros:

```swift
struct SundaeToppings: OptionSet {
    let rawValue: Int
    static let nuts = SundaeToppings(rawValue: 1 << 0)
    static let cherry = SundaeToppings(rawValue: 1 << 1)
    static let fudge = SundaeToppings(rawValue: 1 << 2)
}
```

In this code,
each of the options in the `SundaeToppings` option set
includes a call to the initializer,
which is repetitive and manual.
It would be easy to make a mistake when adding a new option,
like typing the wrong number at the end of the line.

Here's a version of this code that uses a macro instead:

```swift
@OptionSet<Int>
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }
}
```

This version of `SundaeToppings`
calls the `OptionSet` macro from the Swift standard library.
The macro reads the list of cases in the private enumeration,
generates the list of constants for each option,
and adds a conformance to the `OptionSet` protocol.

<!-- XXX link above to both the macro and the protocol -->
[`OptionSet`]: https://developer.apple.com/documentation/swift/optionset

For comparison,
after the compiler expands the `@OptionSet` macro,
here's what the source code looks like:

```swift
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }

    typealias RawValue = Int
    var rawValue: RawValue
    init() { self.rawValue = 0 }
    init(rawValue: RawValue) { self.rawValue = rawValue }
    static let nuts: Self = Self(rawValue: 1 << Options.nuts.rawValue)
    static let cherry: Self = Self(rawValue: 1 << Options.cherry.rawValue)
    static let fudge: Self = Self(rawValue: 1 << Options.fudge.rawValue)
}
extension SundaeToppings: OptionSet  {}
```

## Macro Declarations

Unlike other declarations in Swift,
you declare a macro separate from its implementation.
A macro declaration includes the `macro` keyword
as well as the macro's name, what parameters it takes,
where it can be used,
and what kind of code it generates.
For example,
here's part of the declaration for
`@OptionSet` from the Swift standard library:

```swift
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

The first line
specifies the macro's name, `OptionSet`,
and the arguments that takes, in this case none.
The second line tells Swift
where to find the implementation of this macro.
In this case,
the `SwiftMacros` module
contains a type named `OptionSetMacro`,
which implements this macro.

<!-- XXX TR:
Is there any other syntax besides #externalMacro
that's common enough to call out in the guide,
versus just being covered in the reference?
-->

> Note:
> Macros are always declared as `public`.
> Because the code that declares a macro
> is always in a different module from code that uses that macro,
> there isn't anywhere in your source code
> where you could apply a non-public macro.

The declaration of `@OptionSet` above is incomplete ---
a macro declaration also includes information about
where that macro can be used,
and information about how the symbols generated by the macro are named.
Here's the full declaration:

```swift
@attached(member, names: named(RawValue), named(rawValue), named(`init`), arbitrary)
@attached(conformance)
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

The `@attached` attribute on this macro declaration
indicates that the `@OptionSet` macro is an attached macro.
That attribute appears twice in this declaration,
once for each macro role that `@OptionSet` has.

A *macro role* indicates where the code that the macro generate goes.
The `@OptionSet` macro above has two roles: member and conformance.
A member macro adds new members to the type you apply the macro to.
A conformance macro adds protocol conformance to that type.

For more information about macro roles,
see <doc:Attributes#attached> and <doc:Attributes:freestanding>
in <doc:Attributes>

The first line gives it the member role,
and lists the names of the members that the macro generates ---
`RawValue`, `rawValue`, and `init`.
XXX it also lists "arbitrary"


For a freestanding macros,
you use the `@freestanding` attribute instead,
as discussed below.  <!-- XXX write the referent -->

XXX OUTLINE:

- [This section is mainly focused on *reading* a macro declaration]

- Freestanding macros are marked with `@freestanding`.
  Attached macros are marked with `@attached`.

- Arguments to those macros describe usage more specifically:

- Every declaration that a macro creates in its expansion
  must be included in the list of names the macro declares in an attribute.
  Exception: A macro that uses `arbitrary`.
  However, a macro can declare a name
  but omit a corresponding declaration in the expansion.
  (For example, because one already exists.)

- Macro declaration lists the names of the generated symbols

- After the `=` you either write `#externalMacro(module:type:)`
  or call a different macro that expands to the macro's implementation.

XXX OUTLINE freestanding:

- Macro declaration includes `@freestanding(expression)`.

- Example of a macro and its expanded form.

  `#colorLiteral(red:green:blue)` expands to `Color.init(red:green:blue)`

  XXX use a different example — colorLiteral has uninteresting expansion

XXX OUTLINE attached:

- Macro declaration includes `@attached`
  followed by information about the kinds of code the macro produces,
  and information about the names of the generated symbols.

- Expansion works the same way as for freestanding macros.
  Arguments also work the same way.

- Example of a macro and its expanded form.

## Macro Expansion

XXX OUTLINE:

- The macro expansion process:

  1. The compiler ensures that the code inside the macro call is valid Swift.
  1. The compiler represents your code in memory
     using an abstract syntax tree.
  1. The compiler calls the code that implements the macro,
     passing it information about context where the macro appeared.
  1. The macro implementation creates new AST nodes.
  1. The compiler splices the new AST nodes into the declaration.
  1. The compiler builds the expanded Swift code.

- Figure: moving parts [see ASCII art below]

- Macro arguments are type-checked before macro expansion.
  The macro implementation transforms well-typed, well-formed input
  into well-typed, well-formed output.

- Macros can be nested.
  Nested macros are expanded from the outside in.
  XXX TR: Is there any limit to nesting?
  XXX TR: Is it valid to nest like this -- if so, anything to note about it?

  ```
  let something = #someMacro {
      struct A { }
      @someMacro struct B { }
  }
  ```

- Macro recursion is limited.
  One macro can call another,
  but a given macro can't directly or indirectly call itself.
  The result of macro expansion can include other macros,
  but it can't include a macro that uses this macro in its expansion
  or declare a new macro.
  (XXX likely need to iterate with Doug here)

- Macro expansion happens in their surrounding context.
  A macro can affect that environment if it needs to —
  and a macro that has bugs can interfere with that environment.
  (XXX Give guidance on when you'd do this.  It should be rare.)

- Generated symbol names let a macro
  avoid accidentally interacting with symbols in that environment.
  To generate a unique symbol name,
  call the `MacroExpansionContext.makeUniqueName()` method.

* * *

All of the components of the Swift macro system are made up of Swift code:

- The declaration of a Swift macro,
  including information about where it can appear
  and what kind of output it produces,
  is written in Swift like the declaration of a structure or function.

- The implementation of a macro is written in Swift,
  using the functionality provided by the [SwiftSyntax][] module
  to read and generate Swift code.

- The result of macro expansion is Swift code.

[SwiftSyntax]: http://github.com/apple/swift-syntax/

* * *

If you've used macros in another programming language,
some parts of Swift macros will be familiar
and some parts will feel different.

hygienic macros
gensym

XXX END OUTLINE BITS XXX

To illustrate the process of expanding a macro,
consider the following code:

```swift
let black = #colorLiteral(red: 0, green: 0, blue: 0)
```

<!-- XXX
need to replace colorLiteral, which seems to still be a special literal
grepping for 'macro colorLiteral' in the stdlib source has no results
-->

Swift reads this code,
checks its syntax and types,
and produces a structured representation of the code in memory
called an *abstract syntax tree* (AST).
The AST is made of nodes that correspond to
the meaning and structure of the code that it represents.
A simplified AST for the code above looks like this:

- Constant declaration
    - Identifier `black`
    - Initial value
        - Macro
            - Identifier `colorLiteral`
            - Arguments
                - Label `red:`
                - Integer literal `0`
                - Label `green:`
                - Integer literal `0`
                - Label `blue:`
                - Integer literal `0`

To continue with compilation,
Swift needs to expand the `colorLiteral(red:green:blue:)` macro.
It passes that part of the AST
to another executable that implements this macro.
Here's what the macro implementation sees:

- Macro
    - Identifier `colorLiteral`
    - Arguments
        - Label `red:`
        - Integer literal `0`
        - Label `green:`
        - Integer literal `0`
        - Label `blue:`
        - Integer literal `0`

A macro expansion operates only on the code that contains the macro.
In this example,
that means that the AST nodes representing `let black =` are omitted.

The implementation of the `colorLiteral(red:green:blue:)` macro
generates a new AST with the expanded version of the macro,
calling an initializer on `Color` directly.
Here's what the macro implementation returns:

- Function call
    - Member access
        - Identifier `Color`
        - Identifier `init`
    - Arguments
        - Label `red:`
        - Integer literal `0`
        - Label `green:`
        - Integer literal `0`
        - Label `blue:`
        - Integer literal `0`

The macro implementation sends this new AST back to the compiler.
Swift replaces the macro node in the AST
with the newly expanded version,
and then checks that the resulting AST is syntactically valid
and that the values in it have the needed types.
The AST looks like this after macro expansion:

- Constant declaration
    - Identifier `black`
    - Initial value
    - Function call
        - Member access
            - Identifier `Color`
            - Identifier `init`
        - Arguments
            - Label `red:`
            - Integer literal `0`
            - Label `green:`
            - Integer literal `0`
            - Label `blue:`
            - Integer literal `0`

Finally,
the code is compiled
as if it had been written in source
in the expanded form.

```swift
let black = Color.init(red: 0, green: 0, blue: 0)
```

## Implementing a Macro

[TODO: Re-order for better flow, and split into multiple sections.]

XXX OUTLINE:

- You use the `SwiftSyntax` APIs to modify swift code
  by manipulating the abstract syntax tree (AST).

- Link to `SwiftSyntax` repository
  <https://github.com/apple/swift-syntax/>

- Setting up the SwiftPM bits.
  This should include an example `Package.swift` file
  and a list of the moving parts:
  a package that contains the macro implementation,
  a package that exposes the macro as API,
  and your code that uses the macro
  (which might be in a different package).

- Note:
  Behind the scenes, Swift serializes and deserializes the AST,
  to pass the data across process boundaries,
  but your macro implementation doesn't need to deal with any of that.

- Your type that implements an expression macro
  conforms to the `ExpresionMacro` protocol,
  and implements the required method:

  ```swift
  static func expansion<
    Node: FreestandingMacroExpansionSyntax,
    Context: MacroExpansionContext
  >(
    of node: Node,
    in context: Context
  ) throws -> ExprSyntax
  ```

- This method is passed the specific AST node representing your macro.

- This method is also passed a macro-expansion context, which you use to:

    + Generate unique symbol names
    + Produce diagnostics (`Diagnostic` and `SimpleDiagnosticMessage`)
    + Find a node's location in source

- Ways to create a syntax node include
  Making an instance of the `Syntax` struct,
  or `SyntaxToken`
  or `ExprSyntax`.
  (Need to give folks some general ideas,
  and enough guidance so they can sort through
  all the various `SwiftSyntax` node types and find the right one.)

- Implementation tip:
  All of the types you need to return
  (`ExprSyntax`, `DeclSyntax`, `TypeSyntax`, and so on)
  conform to the `StringLiteralConvertible` protocol ---
  so you can use string interpolation to create the resulting AST nodes.
  XXX show an example of the `\(raw:)` and non-raw version.

  The APIs come from here
  https://github.com/apple/swift-syntax/blob/main/Sources/SwiftSyntaxBuilder/Syntax%2BStringInterpolation.swift

- Attached macros follow the same general model as expression macros,
  but with more moving parts.

- Pick the subprotocol of `AttachedMacro` to conform to,
  depending on which kind of attached macro you're making.
  [This is probably a table]

  + `AccessorMacro` goes with `@attached(accessor)`
  + `ConformanceMacro` goes with `@attached(conformance)`
    [XXX missing from the list under Declaring a Macro]
  + `MemberMacro` goes with `@attached(member)`
  + `PeerMacro` goes with `@attached(peer)`
  + `MemberAttributeMacro` goes with `@member(memberAttribute)`

- Code example of conforming to `MemberMacro`.

  ```
  static func expansion<
    Declaration: DeclGroupSyntax,
    Context: MacroExpansionContext
  >(
    of node: AttributeSyntax,
    providingMembersOf declaration: Declaration,
    in context: Context
  ) throws -> [DeclSyntax]
  ```

- Adding a new member by making an instance of `Declaration`,
  and returning it as part of the `[DeclSyntax]` list.

XXX MOVED PROSE:

Why can't my macro and the rest of my code all be in one target?
In brief, because that would create a circular dependency.
A macro's implementation has to be compiled
before it can be used to compile other code.
So if your single-target project contained both the macro
and other code that used the macro,
then the compiler would have had to already compiled your code
in order to have the macro expanded and be able to compiler your code.
XXX
Also, the macro runs on your development machine
but the final build product might run elsewhere ---
like compiling code on a computer
to run on a server or mobile device.

## Debugging Macros

XXX OUTLINE:

- Ways to view the macro expansion while debugging.
  The SE prototype provides `-Xfrontend -dump-macro-expansions` for this.
  [XXX TR: Is this flag what we should suggest folks use,
  or will there be better command-line options coming?]

- Because macros are deterministic and stateless ---
  they don't depend on any external state,
  don't have any side effects ---
  they're a great place to use use test cases during development.

- Use diagnostics for macros that have constraints/requirements
  so your code can give a meaningful error to users when those aren't met,
  instead of letting the compiler try & fail to build the generated code.

- idempotency and sandboxing

<!-- XXX
Additional APIs and concepts to introduce in the future,
in no particular order:

- Using `SyntaxRewriter` and the visitor pattern for modifying the AST

- Adding a suggested correction using `FixIt`

- concept of trivia

- `TokenSyntax`
-->

<!--
This source file is part of the Swift.org open source project

Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
Licensed under Apache License v2.0 with Runtime Library Exception

See https://swift.org/LICENSE.txt for license information
See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-->
